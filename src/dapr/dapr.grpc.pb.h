// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: dapr.proto
// Original file comments:
// Dapr 0.5.0 Release
//
#ifndef GRPC_dapr_2eproto__INCLUDED
#define GRPC_dapr_2eproto__INCLUDED

#include "dapr.pb.h"

<<<<<<< HEAD
#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/method_handler_impl.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class RpcService;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

=======
#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

>>>>>>> master
namespace dapr {

// Dapr definitions
class Dapr final {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status PublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncPublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncPublishEventRaw(context, request, cq));
    }
    virtual ::grpc::Status InvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope& request, ::dapr::InvokeServiceResponseEnvelope* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::InvokeServiceResponseEnvelope>> AsyncInvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::InvokeServiceResponseEnvelope>>(AsyncInvokeServiceRaw(context, request, cq));
    }
    virtual ::grpc::Status InvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncInvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncInvokeBindingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope& request, ::dapr::GetStateResponseEnvelope* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetStateResponseEnvelope>> AsyncGetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetStateResponseEnvelope>>(AsyncGetStateRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::dapr::GetSecretResponseEnvelope* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetSecretResponseEnvelope>> AsyncGetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetSecretResponseEnvelope>>(AsyncGetSecretRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::dapr::GetSecretResponseEnvelope* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetSecretResponseEnvelope>> AsyncGetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetSecretResponseEnvelope>>(AsyncGetSecretRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetSecretResponseEnvelope>> PrepareAsyncGetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetSecretResponseEnvelope>>(PrepareAsyncGetSecretRaw(context, request, cq));
    }
    virtual ::grpc::Status SaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncSaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncSaveStateRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteStateRaw(context, request, cq));
    }
<<<<<<< HEAD
=======
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteStateRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void PublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PublishEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PublishEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PublishEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void InvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InvokeService(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::InvokeServiceResponseEnvelope* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void InvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void InvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void InvokeService(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::InvokeServiceResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void InvokeService(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::InvokeServiceResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void InvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InvokeBinding(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void InvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void InvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void InvokeBinding(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void InvokeBinding(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetStateResponseEnvelope* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetStateResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetStateResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSecret(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetSecretResponseEnvelope* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSecret(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetSecretResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSecret(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetSecretResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SaveState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SaveState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SaveState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
>>>>>>> master
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncPublishEventRaw(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dapr::InvokeServiceResponseEnvelope>* AsyncInvokeServiceRaw(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncInvokeBindingRaw(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetStateResponseEnvelope>* AsyncGetStateRaw(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
<<<<<<< HEAD
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetSecretResponseEnvelope>* AsyncGetSecretRaw(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
=======
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetStateResponseEnvelope>* PrepareAsyncGetStateRaw(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetSecretResponseEnvelope>* AsyncGetSecretRaw(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dapr::GetSecretResponseEnvelope>* PrepareAsyncGetSecretRaw(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
>>>>>>> master
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncSaveStateRaw(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteStateRaw(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status PublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncPublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncPublishEventRaw(context, request, cq));
    }
    ::grpc::Status InvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope& request, ::dapr::InvokeServiceResponseEnvelope* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::InvokeServiceResponseEnvelope>> AsyncInvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::InvokeServiceResponseEnvelope>>(AsyncInvokeServiceRaw(context, request, cq));
    }
    ::grpc::Status InvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncInvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncInvokeBindingRaw(context, request, cq));
    }
    ::grpc::Status GetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope& request, ::dapr::GetStateResponseEnvelope* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::GetStateResponseEnvelope>> AsyncGetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::GetStateResponseEnvelope>>(AsyncGetStateRaw(context, request, cq));
    }
    ::grpc::Status GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::dapr::GetSecretResponseEnvelope* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::GetSecretResponseEnvelope>> AsyncGetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::GetSecretResponseEnvelope>>(AsyncGetSecretRaw(context, request, cq));
    }
    ::grpc::Status GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::dapr::GetSecretResponseEnvelope* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::GetSecretResponseEnvelope>> AsyncGetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::GetSecretResponseEnvelope>>(AsyncGetSecretRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::GetSecretResponseEnvelope>> PrepareAsyncGetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dapr::GetSecretResponseEnvelope>>(PrepareAsyncGetSecretRaw(context, request, cq));
    }
    ::grpc::Status SaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncSaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncSaveStateRaw(context, request, cq));
    }
    ::grpc::Status DeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteStateRaw(context, request, cq));
    }
<<<<<<< HEAD
=======
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteStateRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void PublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void PublishEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PublishEvent(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PublishEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PublishEvent(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void InvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response, std::function<void(::grpc::Status)>) override;
      void InvokeService(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::InvokeServiceResponseEnvelope* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void InvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void InvokeService(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void InvokeService(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::InvokeServiceResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void InvokeService(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::InvokeServiceResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void InvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void InvokeBinding(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void InvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void InvokeBinding(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void InvokeBinding(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void InvokeBinding(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response, std::function<void(::grpc::Status)>) override;
      void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetStateResponseEnvelope* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetState(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetStateResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetStateResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response, std::function<void(::grpc::Status)>) override;
      void GetSecret(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetSecretResponseEnvelope* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSecret(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSecret(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetSecretResponseEnvelope* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSecret(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::dapr::GetSecretResponseEnvelope* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void SaveState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SaveState(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SaveState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SaveState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteState(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }
>>>>>>> master

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncPublishEventRaw(::grpc::ClientContext* context, const ::dapr::PublishEventEnvelope& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dapr::InvokeServiceResponseEnvelope>* AsyncInvokeServiceRaw(::grpc::ClientContext* context, const ::dapr::InvokeServiceEnvelope& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncInvokeBindingRaw(::grpc::ClientContext* context, const ::dapr::InvokeBindingEnvelope& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dapr::GetStateResponseEnvelope>* AsyncGetStateRaw(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope& request, ::grpc::CompletionQueue* cq) override;
<<<<<<< HEAD
    ::grpc::ClientAsyncResponseReader< ::dapr::GetSecretResponseEnvelope>* AsyncGetSecretRaw(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) override;
=======
    ::grpc::ClientAsyncResponseReader< ::dapr::GetStateResponseEnvelope>* PrepareAsyncGetStateRaw(::grpc::ClientContext* context, const ::dapr::GetStateEnvelope& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dapr::GetSecretResponseEnvelope>* AsyncGetSecretRaw(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dapr::GetSecretResponseEnvelope>* PrepareAsyncGetSecretRaw(::grpc::ClientContext* context, const ::dapr::GetSecretEnvelope& request, ::grpc::CompletionQueue* cq) override;
>>>>>>> master
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncSaveStateRaw(::grpc::ClientContext* context, const ::dapr::SaveStateEnvelope& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteStateRaw(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope& request, ::grpc::CompletionQueue* cq) override;
<<<<<<< HEAD
    const ::grpc::RpcMethod rpcmethod_PublishEvent_;
    const ::grpc::RpcMethod rpcmethod_InvokeService_;
    const ::grpc::RpcMethod rpcmethod_InvokeBinding_;
    const ::grpc::RpcMethod rpcmethod_GetState_;
    const ::grpc::RpcMethod rpcmethod_GetSecret_;
    const ::grpc::RpcMethod rpcmethod_SaveState_;
    const ::grpc::RpcMethod rpcmethod_DeleteState_;
=======
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteStateRaw(::grpc::ClientContext* context, const ::dapr::DeleteStateEnvelope& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PublishEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_InvokeService_;
    const ::grpc::internal::RpcMethod rpcmethod_InvokeBinding_;
    const ::grpc::internal::RpcMethod rpcmethod_GetState_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSecret_;
    const ::grpc::internal::RpcMethod rpcmethod_SaveState_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteState_;
>>>>>>> master
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status PublishEvent(::grpc::ServerContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status InvokeService(::grpc::ServerContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response);
    virtual ::grpc::Status InvokeBinding(::grpc::ServerContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status GetState(::grpc::ServerContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response);
    virtual ::grpc::Status GetSecret(::grpc::ServerContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response);
    virtual ::grpc::Status SaveState(::grpc::ServerContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status DeleteState(::grpc::ServerContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_PublishEvent() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishEvent(::grpc::ServerContext* context, ::dapr::PublishEventEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InvokeService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_InvokeService() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_InvokeService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeService(::grpc::ServerContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInvokeService(::grpc::ServerContext* context, ::dapr::InvokeServiceEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::dapr::InvokeServiceResponseEnvelope>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InvokeBinding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_InvokeBinding() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_InvokeBinding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeBinding(::grpc::ServerContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInvokeBinding(::grpc::ServerContext* context, ::dapr::InvokeBindingEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetState() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetState(::grpc::ServerContext* context, ::dapr::GetStateEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::dapr::GetStateResponseEnvelope>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSecret : public BaseClass {
<<<<<<< HEAD
=======
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSecret() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetSecret() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSecret(::grpc::ServerContext* /*context*/, const ::dapr::GetSecretEnvelope* /*request*/, ::dapr::GetSecretResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSecret(::grpc::ServerContext* context, ::dapr::GetSecretEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::dapr::GetSecretResponseEnvelope>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SaveState : public BaseClass {
>>>>>>> master
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
<<<<<<< HEAD
    WithAsyncMethod_GetSecret() {
      ::grpc::Service::MarkMethodAsync(4);
=======
    WithAsyncMethod_SaveState() {
      ::grpc::Service::MarkMethodAsync(5);
>>>>>>> master
    }
    ~WithAsyncMethod_GetSecret() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSecret(::grpc::ServerContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
<<<<<<< HEAD
    void RequestGetSecret(::grpc::ServerContext* context, ::dapr::GetSecretEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::dapr::GetSecretResponseEnvelope>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
=======
    void RequestSaveState(::grpc::ServerContext* context, ::dapr::SaveStateEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
>>>>>>> master
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SaveState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
<<<<<<< HEAD
    WithAsyncMethod_SaveState() {
      ::grpc::Service::MarkMethodAsync(5);
=======
    WithAsyncMethod_DeleteState() {
      ::grpc::Service::MarkMethodAsync(6);
>>>>>>> master
    }
    ~WithAsyncMethod_SaveState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveState(::grpc::ServerContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
<<<<<<< HEAD
    void RequestSaveState(::grpc::ServerContext* context, ::dapr::SaveStateEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteState : public BaseClass {
=======
    void RequestDeleteState(::grpc::ServerContext* context, ::dapr::DeleteStateEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PublishEvent<WithAsyncMethod_InvokeService<WithAsyncMethod_InvokeBinding<WithAsyncMethod_GetState<WithAsyncMethod_GetSecret<WithAsyncMethod_SaveState<WithAsyncMethod_DeleteState<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PublishEvent() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::dapr::PublishEventEnvelope, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response) { return this->PublishEvent(context, request, response); }));}
    void SetMessageAllocatorFor_PublishEvent(
        ::grpc::experimental::MessageAllocator< ::dapr::PublishEventEnvelope, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::dapr::PublishEventEnvelope, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* /*context*/, const ::dapr::PublishEventEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PublishEvent(
      ::grpc::CallbackServerContext* /*context*/, const ::dapr::PublishEventEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PublishEvent(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::dapr::PublishEventEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_InvokeService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_InvokeService() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::dapr::InvokeServiceEnvelope, ::dapr::InvokeServiceResponseEnvelope>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response) { return this->InvokeService(context, request, response); }));}
    void SetMessageAllocatorFor_InvokeService(
        ::grpc::experimental::MessageAllocator< ::dapr::InvokeServiceEnvelope, ::dapr::InvokeServiceResponseEnvelope>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::dapr::InvokeServiceEnvelope, ::dapr::InvokeServiceResponseEnvelope>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_InvokeService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeService(::grpc::ServerContext* /*context*/, const ::dapr::InvokeServiceEnvelope* /*request*/, ::dapr::InvokeServiceResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* InvokeService(
      ::grpc::CallbackServerContext* /*context*/, const ::dapr::InvokeServiceEnvelope* /*request*/, ::dapr::InvokeServiceResponseEnvelope* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* InvokeService(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::dapr::InvokeServiceEnvelope* /*request*/, ::dapr::InvokeServiceResponseEnvelope* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_InvokeBinding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_InvokeBinding() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::dapr::InvokeBindingEnvelope, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response) { return this->InvokeBinding(context, request, response); }));}
    void SetMessageAllocatorFor_InvokeBinding(
        ::grpc::experimental::MessageAllocator< ::dapr::InvokeBindingEnvelope, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::dapr::InvokeBindingEnvelope, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_InvokeBinding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeBinding(::grpc::ServerContext* /*context*/, const ::dapr::InvokeBindingEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* InvokeBinding(
      ::grpc::CallbackServerContext* /*context*/, const ::dapr::InvokeBindingEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* InvokeBinding(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::dapr::InvokeBindingEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetState : public BaseClass {
>>>>>>> master
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
<<<<<<< HEAD
    WithAsyncMethod_DeleteState() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeleteState() override {
=======
    ExperimentalWithCallbackMethod_GetState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::dapr::GetStateEnvelope, ::dapr::GetStateResponseEnvelope>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response) { return this->GetState(context, request, response); }));}
    void SetMessageAllocatorFor_GetState(
        ::grpc::experimental::MessageAllocator< ::dapr::GetStateEnvelope, ::dapr::GetStateResponseEnvelope>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::dapr::GetStateEnvelope, ::dapr::GetStateResponseEnvelope>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* /*context*/, const ::dapr::GetStateEnvelope* /*request*/, ::dapr::GetStateResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetState(
      ::grpc::CallbackServerContext* /*context*/, const ::dapr::GetStateEnvelope* /*request*/, ::dapr::GetStateResponseEnvelope* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::dapr::GetStateEnvelope* /*request*/, ::dapr::GetStateResponseEnvelope* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSecret : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSecret() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::dapr::GetSecretEnvelope, ::dapr::GetSecretResponseEnvelope>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response) { return this->GetSecret(context, request, response); }));}
    void SetMessageAllocatorFor_GetSecret(
        ::grpc::experimental::MessageAllocator< ::dapr::GetSecretEnvelope, ::dapr::GetSecretResponseEnvelope>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::dapr::GetSecretEnvelope, ::dapr::GetSecretResponseEnvelope>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSecret() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSecret(::grpc::ServerContext* /*context*/, const ::dapr::GetSecretEnvelope* /*request*/, ::dapr::GetSecretResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSecret(
      ::grpc::CallbackServerContext* /*context*/, const ::dapr::GetSecretEnvelope* /*request*/, ::dapr::GetSecretResponseEnvelope* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSecret(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::dapr::GetSecretEnvelope* /*request*/, ::dapr::GetSecretResponseEnvelope* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SaveState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SaveState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::dapr::SaveStateEnvelope, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response) { return this->SaveState(context, request, response); }));}
    void SetMessageAllocatorFor_SaveState(
        ::grpc::experimental::MessageAllocator< ::dapr::SaveStateEnvelope, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::dapr::SaveStateEnvelope, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SaveState() override {
>>>>>>> master
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteState(::grpc::ServerContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
<<<<<<< HEAD
    void RequestDeleteState(::grpc::ServerContext* context, ::dapr::DeleteStateEnvelope* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PublishEvent<WithAsyncMethod_InvokeService<WithAsyncMethod_InvokeBinding<WithAsyncMethod_GetState<WithAsyncMethod_GetSecret<WithAsyncMethod_SaveState<WithAsyncMethod_DeleteState<Service > > > > > > > AsyncService;
=======
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SaveState(
      ::grpc::CallbackServerContext* /*context*/, const ::dapr::SaveStateEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SaveState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::dapr::SaveStateEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::dapr::DeleteStateEnvelope, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response) { return this->DeleteState(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteState(
        ::grpc::experimental::MessageAllocator< ::dapr::DeleteStateEnvelope, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::dapr::DeleteStateEnvelope, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteState(::grpc::ServerContext* /*context*/, const ::dapr::DeleteStateEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteState(
      ::grpc::CallbackServerContext* /*context*/, const ::dapr::DeleteStateEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::dapr::DeleteStateEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_PublishEvent<ExperimentalWithCallbackMethod_InvokeService<ExperimentalWithCallbackMethod_InvokeBinding<ExperimentalWithCallbackMethod_GetState<ExperimentalWithCallbackMethod_GetSecret<ExperimentalWithCallbackMethod_SaveState<ExperimentalWithCallbackMethod_DeleteState<Service > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_PublishEvent<ExperimentalWithCallbackMethod_InvokeService<ExperimentalWithCallbackMethod_InvokeBinding<ExperimentalWithCallbackMethod_GetState<ExperimentalWithCallbackMethod_GetSecret<ExperimentalWithCallbackMethod_SaveState<ExperimentalWithCallbackMethod_DeleteState<Service > > > > > > > ExperimentalCallbackService;
>>>>>>> master
  template <class BaseClass>
  class WithGenericMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_PublishEvent() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InvokeService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_InvokeService() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_InvokeService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeService(::grpc::ServerContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InvokeBinding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_InvokeBinding() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_InvokeBinding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeBinding(::grpc::ServerContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetState() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSecret : public BaseClass {
<<<<<<< HEAD
=======
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSecret() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetSecret() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSecret(::grpc::ServerContext* /*context*/, const ::dapr::GetSecretEnvelope* /*request*/, ::dapr::GetSecretResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SaveState : public BaseClass {
>>>>>>> master
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
<<<<<<< HEAD
    WithGenericMethod_GetSecret() {
      ::grpc::Service::MarkMethodGeneric(4);
=======
    WithGenericMethod_SaveState() {
      ::grpc::Service::MarkMethodGeneric(5);
>>>>>>> master
    }
    ~WithGenericMethod_GetSecret() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSecret(::grpc::ServerContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SaveState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
<<<<<<< HEAD
    WithGenericMethod_SaveState() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SaveState() override {
=======
    WithGenericMethod_DeleteState() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeleteState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteState(::grpc::ServerContext* /*context*/, const ::dapr::DeleteStateEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PublishEvent() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* /*context*/, const ::dapr::PublishEventEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InvokeService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InvokeService() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_InvokeService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeService(::grpc::ServerContext* /*context*/, const ::dapr::InvokeServiceEnvelope* /*request*/, ::dapr::InvokeServiceResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInvokeService(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InvokeBinding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InvokeBinding() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_InvokeBinding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeBinding(::grpc::ServerContext* /*context*/, const ::dapr::InvokeBindingEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInvokeBinding(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetState() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* /*context*/, const ::dapr::GetStateEnvelope* /*request*/, ::dapr::GetStateResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSecret : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSecret() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetSecret() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSecret(::grpc::ServerContext* /*context*/, const ::dapr::GetSecretEnvelope* /*request*/, ::dapr::GetSecretResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSecret(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SaveState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SaveState() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SaveState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveState(::grpc::ServerContext* /*context*/, const ::dapr::SaveStateEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteState() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeleteState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteState(::grpc::ServerContext* /*context*/, const ::dapr::DeleteStateEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PublishEvent() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PublishEvent(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* /*context*/, const ::dapr::PublishEventEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PublishEvent(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PublishEvent(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_InvokeService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_InvokeService() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InvokeService(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_InvokeService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeService(::grpc::ServerContext* /*context*/, const ::dapr::InvokeServiceEnvelope* /*request*/, ::dapr::InvokeServiceResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* InvokeService(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* InvokeService(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_InvokeBinding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_InvokeBinding() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InvokeBinding(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_InvokeBinding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvokeBinding(::grpc::ServerContext* /*context*/, const ::dapr::InvokeBindingEnvelope* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* InvokeBinding(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* InvokeBinding(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetState(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetState(::grpc::ServerContext* /*context*/, const ::dapr::GetStateEnvelope* /*request*/, ::dapr::GetStateResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSecret : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSecret() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSecret(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSecret() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSecret(::grpc::ServerContext* /*context*/, const ::dapr::GetSecretEnvelope* /*request*/, ::dapr::GetSecretResponseEnvelope* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSecret(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSecret(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SaveState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SaveState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SaveState(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SaveState() override {
>>>>>>> master
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveState(::grpc::ServerContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
<<<<<<< HEAD
=======
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SaveState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SaveState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
>>>>>>> master
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
<<<<<<< HEAD
    WithGenericMethod_DeleteState() {
      ::grpc::Service::MarkMethodGeneric(6);
=======
    ExperimentalWithRawCallbackMethod_DeleteState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteState(context, request, response); }));
>>>>>>> master
    }
    ~WithGenericMethod_DeleteState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteState(::grpc::ServerContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
<<<<<<< HEAD
=======
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
>>>>>>> master
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_PublishEvent() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::StreamedUnaryHandler< ::dapr::PublishEventEnvelope, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_PublishEvent<BaseClass>::StreamedPublishEvent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* context, const ::dapr::PublishEventEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPublishEvent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dapr::PublishEventEnvelope,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InvokeService : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_InvokeService() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::StreamedUnaryHandler< ::dapr::InvokeServiceEnvelope, ::dapr::InvokeServiceResponseEnvelope>(std::bind(&WithStreamedUnaryMethod_InvokeService<BaseClass>::StreamedInvokeService, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_InvokeService() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InvokeService(::grpc::ServerContext* context, const ::dapr::InvokeServiceEnvelope* request, ::dapr::InvokeServiceResponseEnvelope* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInvokeService(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dapr::InvokeServiceEnvelope,::dapr::InvokeServiceResponseEnvelope>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InvokeBinding : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_InvokeBinding() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::StreamedUnaryHandler< ::dapr::InvokeBindingEnvelope, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_InvokeBinding<BaseClass>::StreamedInvokeBinding, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_InvokeBinding() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InvokeBinding(::grpc::ServerContext* context, const ::dapr::InvokeBindingEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInvokeBinding(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dapr::InvokeBindingEnvelope,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetState() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::StreamedUnaryHandler< ::dapr::GetStateEnvelope, ::dapr::GetStateResponseEnvelope>(std::bind(&WithStreamedUnaryMethod_GetState<BaseClass>::StreamedGetState, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetState(::grpc::ServerContext* context, const ::dapr::GetStateEnvelope* request, ::dapr::GetStateResponseEnvelope* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dapr::GetStateEnvelope,::dapr::GetStateResponseEnvelope>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSecret : public BaseClass {
   private:
<<<<<<< HEAD
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetSecret() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::StreamedUnaryHandler< ::dapr::GetSecretEnvelope, ::dapr::GetSecretResponseEnvelope>(std::bind(&WithStreamedUnaryMethod_GetSecret<BaseClass>::StreamedGetSecret, this, std::placeholders::_1, std::placeholders::_2)));
=======
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSecret() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::dapr::GetSecretEnvelope, ::dapr::GetSecretResponseEnvelope>(std::bind(&WithStreamedUnaryMethod_GetSecret<BaseClass>::StreamedGetSecret, this, std::placeholders::_1, std::placeholders::_2)));
>>>>>>> master
    }
    ~WithStreamedUnaryMethod_GetSecret() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
<<<<<<< HEAD
    ::grpc::Status GetSecret(::grpc::ServerContext* context, const ::dapr::GetSecretEnvelope* request, ::dapr::GetSecretResponseEnvelope* response) final override {
=======
    ::grpc::Status GetSecret(::grpc::ServerContext* /*context*/, const ::dapr::GetSecretEnvelope* /*request*/, ::dapr::GetSecretResponseEnvelope* /*response*/) override {
>>>>>>> master
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSecret(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dapr::GetSecretEnvelope,::dapr::GetSecretResponseEnvelope>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SaveState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SaveState() {
      ::grpc::Service::MarkMethodStreamed(5,
<<<<<<< HEAD
        new ::grpc::StreamedUnaryHandler< ::dapr::SaveStateEnvelope, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_SaveState<BaseClass>::StreamedSaveState, this, std::placeholders::_1, std::placeholders::_2)));
=======
        new ::grpc::internal::StreamedUnaryHandler< ::dapr::SaveStateEnvelope, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_SaveState<BaseClass>::StreamedSaveState, this, std::placeholders::_1, std::placeholders::_2)));
>>>>>>> master
    }
    ~WithStreamedUnaryMethod_SaveState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SaveState(::grpc::ServerContext* context, const ::dapr::SaveStateEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSaveState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dapr::SaveStateEnvelope,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteState() {
      ::grpc::Service::MarkMethodStreamed(6,
<<<<<<< HEAD
        new ::grpc::StreamedUnaryHandler< ::dapr::DeleteStateEnvelope, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_DeleteState<BaseClass>::StreamedDeleteState, this, std::placeholders::_1, std::placeholders::_2)));
=======
        new ::grpc::internal::StreamedUnaryHandler< ::dapr::DeleteStateEnvelope, ::google::protobuf::Empty>(std::bind(&WithStreamedUnaryMethod_DeleteState<BaseClass>::StreamedDeleteState, this, std::placeholders::_1, std::placeholders::_2)));
>>>>>>> master
    }
    ~WithStreamedUnaryMethod_DeleteState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteState(::grpc::ServerContext* context, const ::dapr::DeleteStateEnvelope* request, ::google::protobuf::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dapr::DeleteStateEnvelope,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PublishEvent<WithStreamedUnaryMethod_InvokeService<WithStreamedUnaryMethod_InvokeBinding<WithStreamedUnaryMethod_GetState<WithStreamedUnaryMethod_GetSecret<WithStreamedUnaryMethod_SaveState<WithStreamedUnaryMethod_DeleteState<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PublishEvent<WithStreamedUnaryMethod_InvokeService<WithStreamedUnaryMethod_InvokeBinding<WithStreamedUnaryMethod_GetState<WithStreamedUnaryMethod_GetSecret<WithStreamedUnaryMethod_SaveState<WithStreamedUnaryMethod_DeleteState<Service > > > > > > > StreamedService;
};

}  // namespace dapr


#endif  // GRPC_dapr_2eproto__INCLUDED
